# 自动同步页面逻辑说明

## 核心概念

### 什么是"同步"？
自动同步是指系统自动将 H3Yun ERP 的库存数据同步到各个 WooCommerce 站点。

### 什么是"批次"？
一次完整的同步任务称为一个批次（Batch），包含多个步骤：
- **步骤 0**：从 H3Yun ERP 拉取库存数据
- **步骤 1-N**：依次同步各个 WooCommerce 站点

---

## 页面加载时发生了什么？

### 1. 初始化（第一次打开页面）
页面会并行加载以下数据：
- ✅ 加载自动同步配置（是否启用、选择了哪些站点等）
- ✅ 加载所有站点列表和筛选配置
- ✅ 加载历史同步日志
- ✅ **查询**当前是否有运行中的批次

### 2. 自动刷新状态（有活跃批次时）
如果当前有正在执行的批次：
- 每 10 秒自动查询一次批次状态
- 实时显示进度（步骤 X/N，各站点状态）
- 仅用于显示，不会触发新的同步操作

> **重要**：刷新页面或查询状态 ≠ 触发同步！这只是"查看"，不是"执行"。

---

## 按钮功能详解（从左到右、从上到下）

### 1. 启用自动同步 (Switch 开关)
**位置**: 基础设置卡片
**状态**: `config.enabled`
**作用**:
- `enabled: true` → Vercel Cron 任务会执行同步
- `enabled: false` → Vercel Cron 任务会跳过执行（返回 "自动同步已禁用"）

**工作流程**:
```
用户切换开关 → 更新 config.enabled 状态 → 点击"保存配置"才会生效
```

**注意**:
- 修改后必须点击"保存配置"才会持久化到数据库
- 手动触发调度不受此开关影响

---

### 2. 保存配置 (Button - handleSave)
**位置**: 基础设置卡片底部
**图标**: Save
**作用**: 保存所有配置到数据库

**保存内容**:
1. 全局配置 → `auto_sync_config` 表
   - enabled, site_ids, filters, sync_to_instock, sync_to_outofstock
   - wechat_webhook_url, notify_* 配置
   - cron_expression

2. 各站点筛选配置 → `site_filters` 表
   - 为每个选中的站点保存：
   - sku_filter, exclude_sku_prefixes
   - category_filters, exclude_warehouses

**工作流程**:
```
点击按钮 →
  1. POST /api/sync/auto-config (保存全局配置)
  2. 遍历 siteFilters 对象
  3. 对每个站点 POST /api/sync/site-filters (保存站点筛选配置)
  → 全部成功后显示 "配置已保存"
```

---

### 3. 手动触发调度 (Button - handleTriggerDispatcher)
**位置**: 批次监控卡片
**图标**: Play
**文本**: "手动触发调度"
**作用**: 立即开始一次完整的同步流程

**工作流程**:
```
点击按钮 →
  POST /api/sync/dispatcher →
    检查是否有活跃批次:
      - 有 → 继续执行该批次的下一步
      - 无 → 创建新批次，执行步骤0（拉取ERP数据）
  → 每次 cron 触发时会继续执行后续步骤
```

**与 Cron 的区别**:
- **手动触发**: POST 方法，不检查 `enabled` 状态，立即执行
- **Cron 触发**: GET 方法，检查 `enabled` 状态，如果为 false 则跳过

**批次执行流程**:
```
步骤 0: 拉取 H3Yun ERP 库存数据 + SKU 映射 → 缓存到 Redis
步骤 1: 同步第1个站点
步骤 2: 同步第2个站点
...
步骤 N: 同步第N个站点 → 批次完成 → 发送企业微信通知
```

---

### 4. 终止任务 (Button - handleAbortBatch)
**位置**: 批次监控卡片（仅当有活跃批次时显示）
**图标**: XCircle
**文本**: "终止任务"
**颜色**: destructive (红色)
**作用**: 强制终止当前正在运行的批次

**工作流程**:
```
点击按钮 → 用户确认 →
  POST /api/sync/batch-status (method: DELETE) →
    更新批次状态为 'failed'
    error_message: '用户手动终止'
    completed_at: 当前时间
  → 刷新批次状态
```

**使用场景**:
- 发现配置错误需要中止
- 同步过程出现问题
- 需要重新开始新批次

---

### 5. 刷新状态 (Button)
**位置**: 批次监控卡片
**图标**: RefreshCw
**文本**: "刷新状态"
**作用**: 手动刷新批次和站点状态

**工作流程**:
```
点击按钮 → loadBatchStatus() →
  GET /api/sync/batch-status →
    查询 sync_batches 表
    查询 sync_site_results 表
  → 更新前端显示
```

**注意**:
- **不会触发同步**，只是查询状态
- 自动刷新机制每10秒会自动调用

---

### 6. 诊断问题 (Button - handleDiagnose)
**位置**: 批次监控卡片
**图标**: AlertCircle
**文本**: "诊断问题"
**作用**: 调用诊断 API，分析批次状态和可能的问题

**工作流程**:
```
点击按钮 →
  GET /api/sync/debug-batch →
    分析当前批次状态
    检查步骤执行情况
    提供问题建议
  → 显示诊断结果到前端日志
```

---

### 7. 同步日志 - 清空日志 (Button)
**位置**: 同步日志卡片
**图标**: (无)
**文本**: "清空"
**作用**: 清空前端显示的调试日志

**工作流程**:
```
点击按钮 → setDebugLogs([]) → 清空日志数组
```

**注意**:
- 只清空前端内存中的日志
- 不影响 Vercel 服务器日志
- 不影响数据库中的 sync_batches 和 sync_site_results

---

### 8. 站点卡片 - 更新配置 (Button)
**位置**: 每个站点卡片底部
**文本**: "更新配置"
**作用**: 单独保存该站点的筛选配置

**工作流程**:
```
点击按钮 →
  PATCH /api/sites/{siteId} →
    更新该站点的 site_filters 记录
  → 重新加载站点列表
```

**与"保存配置"的区别**:
- 这个按钮：只保存单个站点的筛选配置
- "保存配置"按钮：保存全局配置 + 所有站点的筛选配置

---

## 完整同步流程示例

### 场景1: 首次配置并启动自动同步

```
1. 用户打开页面
   → 页面加载配置、站点、日志、批次状态

2. 用户配置：
   - 勾选"启用自动同步" ✓
   - 选择要同步的站点
   - 为每个站点配置 SKU 筛选、排除前缀等
   - 配置企业微信通知 webhook

3. 点击"保存配置"
   → 全局配置保存到 auto_sync_config 表
   → 各站点筛选配置保存到 site_filters 表

4. 等待 Vercel Cron 触发（每2分钟一次）
   或点击"手动触发调度"立即开始

5. 调度器执行：
   → 步骤0: 拉取ERP数据（约30秒）
   → 等待下次cron触发（2分钟后）
   → 步骤1: 同步第1个站点（约30-60秒）
   → 等待下次cron触发（2分钟后）
   → 步骤2: 同步第2个站点
   ...
   → 所有站点完成 → 发送企业微信通知 → 批次标记为 completed
```

### 场景2: 中途发现配置错误

```
1. 批次正在运行（步骤 2/5）

2. 用户发现筛选配置有误

3. 点击"终止任务"
   → 批次状态变为 failed
   → 停止执行

4. 修改配置 → 点击"保存配置"

5. 点击"手动触发调度"
   → 创建新批次，重新开始
```

### 场景3: 仅查看状态

```
1. 用户定期打开页面查看同步状态

2. 页面加载时自动查询批次状态（loadBatchStatus）
   → 显示当前批次进度
   → 显示各站点同步结果

3. 如果有活跃批次
   → 每10秒自动刷新状态
   → 实时显示进度

4. 用户可点击"刷新状态"手动刷新
```

---

## 常见误解澄清

### ❌ 误解1: "刷新页面会触发同步"
**真相**: 刷新页面只会查询当前批次状态（`loadBatchStatus`），不会触发新的同步操作。

### ❌ 误解2: "保存配置会立即开始同步"
**真相**: 保存配置只是更新数据库中的配置，不会触发同步。需要等待 Cron 触发或手动点击"手动触发调度"。

### ❌ 误解3: "启用自动同步后会立即开始"
**真相**:
1. 切换开关 → 修改 `config.enabled` 状态
2. 点击"保存配置" → 保存到数据库
3. 等待下次 Cron 触发（每2分钟）或手动触发

### ❌ 误解4: "每个站点需要单独点击'更新配置'"
**真相**: 可以统一使用顶部的"保存配置"按钮，会一次性保存所有站点的筛选配置。单独的"更新配置"按钮是为了方便只修改某个站点时使用。

---

## API 端点总结

| 端点 | 方法 | 作用 | 触发时机 |
|-----|------|------|---------|
| `/api/sync/auto-config` | GET | 获取自动同步配置 | 页面加载 |
| `/api/sync/auto-config` | POST | 保存自动同步配置 | 点击"保存配置" |
| `/api/sites` | GET | 获取站点列表和筛选配置 | 页面加载 |
| `/api/sync/site-filters` | POST | 保存站点筛选配置 | 点击"保存配置" |
| `/api/sync/batch-status` | GET | 查询当前批次状态 | 页面加载、自动刷新、点击"刷新状态" |
| `/api/sync/batch-status` | DELETE | 终止当前批次 | 点击"终止任务" |
| `/api/sync/dispatcher` | POST | 触发调度器（手动） | 点击"手动触发调度" |
| `/api/sync/dispatcher` | GET | 触发调度器（Cron） | Vercel Cron 每2分钟 |
| `/api/sync/debug-batch` | GET | 诊断批次问题 | 点击"诊断问题" |
| `/api/sync/site` | POST | 执行站点同步 | 调度器内部调用（不直接暴露给用户） |

---

## 数据流向图

```
用户操作 → 前端状态更新 → API 调用 → 数据库更新 → 前端显示更新

配置修改:
  用户输入 → setState(config) → 点击保存 → POST /api/sync/auto-config
  → UPDATE auto_sync_config表 → 重新加载配置 → 显示"配置已保存"

手动触发:
  点击按钮 → POST /api/sync/dispatcher →
  → 查询/创建 sync_batches → 执行步骤 →
  → 更新 sync_batches.current_step → 返回结果 → 前端显示

状态查询:
  页面加载/自动刷新/手动刷新 → GET /api/sync/batch-status →
  → 查询 sync_batches + sync_site_results → 返回数据 → 前端显示
```

---

## Redis 缓存说明

调度器在步骤0会将数据缓存到 Redis，后续步骤从缓存读取：

```
步骤 0 (dispatcher):
  - 拉取 H3Yun 库存数据
  - 拉取 SKU 映射
  - 缓存到 Redis (key: batch:{batch_id})
  - 设置过期时间: 2小时

步骤 1-N (site sync):
  - 从 Redis 读取缓存数据
  - 应用站点特定筛选配置
  - 检测产品状态
  - 执行同步
```

这样避免了每个站点都要重新拉取 ERP 数据，大大提高效率。
