# 自动同步问题根因分析

## 问题现象

手动同步检测到 5 个 SKU 需要同步为"有货"，但自动同步报告"无需同步"，所有 247 个 SKU 都被跳过。

---

## 氚云字段说明

| 字段代码 | 字段含义 | 说明 |
|----------|----------|------|
| F0000001 | 产品代码 | SKU 编码 |
| F0000030 | 可用SKU库存 | **实际可用库存数量** |
| F0000055 | 待出库 | 已下单待发货的数量 |
| F0000083 | 可用库存不含待出库 | F0000030 - F0000055 |
| F0000084 | 缺货排队待发 | 缺货订单数量 |
| F0000085 | 可售库存 | **经常为 0，数据不可靠** |

---

## 目标 SKU 的氚云实时数据

```
📦 AK-HO2-14:
   F0000030 (可用SKU库存): 5      ← 真实库存
   F0000085 (可售库存): 0         ← 当前代码优先使用这个
   F0000084 (缺货排队待发): 2

📦 AK-HO2-10:
   F0000030 (可用SKU库存): 14
   F0000085 (可售库存): 14        ← 这个碰巧有值
   F0000084 (缺货排队待发): 30

📦 AK-HO5-06:
   F0000030 (可用SKU库存): 10     ← 真实库存
   F0000085 (可售库存): 0         ← 当前代码优先使用这个
   F0000084 (缺货排队待发): 0
```

---

## 当前字段映射逻辑

文件位置: `src/lib/h3yun/field-mappings.ts`

```typescript
// 第 13-14 行
可售库存: (obj: H3YunBizObject) => String(obj.F0000085 ?? obj.F0000030 ?? 0),

// 第 59 行
缺货: (obj: H3YunBizObject) => String(obj.F0000084 ?? 0),
```

**净库存计算公式**: `净库存 = 可售库存 - 缺货`

---

## 问题根源

### 当前计算结果（错误）

| SKU | 可售库存 (F0000085优先) | 缺货 | 净库存 | 判断结果 |
|-----|-------------------------|------|--------|----------|
| AK-HO2-14 | **0** | 2 | **-2** | 跳过 (<=0) |
| AK-HO2-10 | 14 | 30 | **-16** | 跳过 (<=0) |
| AK-HO5-06 | **0** | 0 | **0** | 跳过 (<=0) |

### 正确计算结果（应该用 F0000030）

| SKU | 可售库存 (F0000030) | 缺货 | 净库存 | 应该的判断 |
|-----|---------------------|------|--------|------------|
| AK-HO2-14 | **5** | 2 | **3** | **需要同步为有货** |
| AK-HO2-10 | 14 | 30 | -16 | 跳过 (<=0) |
| AK-HO5-06 | **10** | 0 | **10** | **需要同步为有货** |

---

## 同步判断逻辑

文件位置: `src/app/api/sync/site/route.ts` 第 513 行

```typescript
// 需要同步为有货的条件：
// 1. WooCommerce 当前状态是 outofstock
// 2. ERP 净库存 > 0
// 3. 配置允许同步为有货
if (currentStockStatus === 'outofstock' && netStock > 0 && config.sync_to_instock) {
  needSync = true;
  targetStatus = 'instock';
}
```

因为 `netStock` 被错误计算为 <=0，所以条件不满足，SKU 被跳过。

---

## 数据流程图

```
氚云 API
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  field-mappings.ts                                       │
│                                                          │
│  可售库存 = F0000085 ?? F0000030 ?? 0                    │
│           ↓                                              │
│  F0000085 = 0 → 使用 0，不会降级到 F0000030              │
│                                                          │
│  ⚠️ 问题: F0000085 经常是 0，但 ?? 只处理 null/undefined │
└─────────────────────────────────────────────────────────┘
    │
    ▼
inventory_cache 表 (Supabase)
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  site/route.ts                                           │
│                                                          │
│  净库存 = 可售库存 - 缺货 = 0 - 2 = -2                   │
│                                                          │
│  if (netStock > 0) → false → 跳过                        │
└─────────────────────────────────────────────────────────┘
```

---

## 核心问题

**`??` 运算符只在值为 `null` 或 `undefined` 时才会使用后备值。**

当 `F0000085 = 0` 时：
- `0 ?? F0000030` 返回 `0`，不会降级到 `F0000030`

如果要在 `F0000085 = 0` 时也降级，需要用 `||` 或显式判断：

```typescript
// 方案 1: 使用 || （0 也会触发降级）
可售库存: (obj) => String(obj.F0000085 || obj.F0000030 || 0),

// 方案 2: 显式判断
可售库存: (obj) => {
  if (obj.F0000085 && obj.F0000085 > 0) return String(obj.F0000085);
  return String(obj.F0000030 ?? 0);
},
```

---

## 手动同步 vs 自动同步 对比

### 手动同步流程

**文件**: `src/lib/sync-core.ts` + `src/lib/inventory-utils.ts`

```typescript
// sync-core.ts 第 70-87 行
export function calculateSyncNeed(item: InventoryItem): SyncNeed {
  if (!item.productData) return 'none';

  const netStock = calculateNetStock(item);  // ← 调用 inventory-utils.ts
  const stockStatus = item.productData.stockStatus;

  // 需要同步为有货：显示无货但净库存>0
  if (stockStatus === 'outofstock' && netStock > 0) {
    return 'to-instock';
  }
  return 'none';
}

// inventory-utils.ts 第 114-119 行
export const calculateNetStock = (item: InventoryItem): number => {
  const 可售库存 = Number(item.可售库存) || 0;  // ← 直接使用 item.可售库存
  const 缺货 = Number(item.缺货) || 0;
  const netStock = 可售库存 - 缺货;
  return netStock;
};
```

**关键**: 手动同步使用的是 `item.可售库存`，这个值来自**前端加载的库存数据**。

### 自动同步流程

**文件**: `src/lib/h3yun/field-mappings.ts` + `src/app/api/sync/site/route.ts`

```typescript
// field-mappings.ts 第 13-14 行
可售库存: (obj: H3YunBizObject) => String(obj.F0000085 ?? obj.F0000030 ?? 0),

// site/route.ts 第 493 行
const netStock = calculateNetStock(item);  // item 来自 inventory_cache
```

**关键**: 自动同步的 `item.可售库存` 来自 `field-mappings.ts` 的转换结果，优先使用 F0000085。

### 数据源差异

| 对比项 | 手动同步 | 自动同步 |
|--------|----------|----------|
| 数据来源 | 前端加载的 H3Yun 数据 | Supabase inventory_cache |
| 转换时机 | 每次打开页面时实时转换 | 批次创建时一次性转换 |
| 字段映射 | 可能使用不同的 API 或参数 | 使用 field-mappings.ts |
| 可售库存字段 | 取决于 /api/h3yun/inventory | 优先 F0000085 |

### 手动同步界面的完整数据流

根据截图确认，你使用的是 `/sync` 页面的 **单站点库存同步** 面板。

**完整数据流**：

```
1. 用户在 /inventory 页面点击"同步库存"
   → H3YunSyncPanel.handleSync()
   → POST /api/h3yun/inventory
   → transformH3YunBatch(h3yunData)
   → FIELD_MAPPINGS.可售库存(obj)  ← 使用 F0000085 ?? F0000030
   → 返回 InventoryItem[] 数组
   → 存入 Zustand inventoryStore

2. 用户切换到 /sync 页面
   → 从 inventoryStore 读取 inventoryData
   → calculateBatchSyncNeeds(filteredData)
   → calculateNetStock(item)  ← 使用 item.可售库存
   → 显示"5个产品建议同步为有货"
```

### 为什么结果不同？答案揭晓！

**两者确实使用相同的字段映射**，但关键区别在于 **数据加载时机**：

| 场景 | 数据加载时间 | 氚云 F0000085 状态 |
|------|--------------|-------------------|
| 你手动加载库存时 | 某个早期时间点 | F0000085 可能有值 |
| 自动同步执行时 | 批次创建时刻 | F0000085 为 0 |

**氚云的 F0000085 字段值可能在不同时间点发生变化！**

### 验证方法

在 `/sync` 页面的库存表格中，查看这些 SKU 的 **可售库存** 列：

- 如果显示 5、14、10 → 说明加载时 F0000085 有值
- 如果显示 0、14、0 → 说明加载时 F0000085 为 0

### 根本解决方案

无论 F0000085 何时有值何时为 0，都应该使用更可靠的字段。

修改 `src/lib/h3yun/field-mappings.ts`，将：
```typescript
可售库存: (obj) => String(obj.F0000085 ?? obj.F0000030 ?? 0),
```

改为：
```typescript
可售库存: (obj) => {
  // F0000085 有值且 > 0 时使用，否则使用 F0000030
  const f85 = obj.F0000085;
  if (f85 !== undefined && f85 !== null && f85 > 0) {
    return String(f85);
  }
  return String(obj.F0000030 ?? 0);
},
```

这样可以确保：
- 当 F0000085 = 0 时，降级使用 F0000030
- 当 F0000085 有正值时，优先使用 F0000085

---

## 修复建议

修改 `src/lib/h3yun/field-mappings.ts` 第 13-14 行：

```typescript
// 修改前（有问题）
可售库存: (obj: H3YunBizObject) => String(obj.F0000085 ?? obj.F0000030 ?? 0),

// 修改后（推荐）
可售库存: (obj: H3YunBizObject) => {
  // F0000085 有值且 > 0 时使用，否则降级到 F0000030
  const f85 = obj.F0000085;
  if (f85 !== undefined && f85 !== null && f85 > 0) {
    return String(f85);
  }
  return String(obj.F0000030 ?? 0);
},
```

或者更简洁：

```typescript
// 直接优先使用 F0000030，因为它更可靠
可售库存: (obj: H3YunBizObject) => String(obj.F0000030 ?? obj.F0000085 ?? 0),
```

---

## 验证脚本

运行以下命令验证氚云实时数据：

```bash
node scripts/query-h3yun-live.js
```

运行以下命令检查缓存数据：

```bash
node scripts/check-cache.js
```

---

## 总结

| 项目 | 说明 |
|------|------|
| 问题类型 | 字段优先级配置错误 |
| 问题文件 | `src/lib/h3yun/field-mappings.ts` |
| 问题代码 | `obj.F0000085 ?? obj.F0000030` |
| 根本原因 | F0000085 经常为 0，但 `??` 不会将 0 视为空值 |
| 影响范围 | 所有依赖"可售库存"字段的逻辑 |
| 修复方案 | 调整字段优先级或使用 `\|\|` 替代 `??` |
