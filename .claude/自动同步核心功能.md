# 自动同步核心功能详解

> 本文档详细解释 ERP → WooCommerce 库存自动同步的核心逻辑，可作为从零开始理解或重构的参考。

---

## 目录

1. [概述](#概述)
2. [数据结构](#数据结构)
3. [产品状态检测（三层缓存策略）](#产品状态检测三层缓存策略)
4. [同步决策逻辑（四种情况）](#同步决策逻辑四种情况)
5. [执行同步（syncSku函数）](#执行同步syncsku函数)
6. [日志记录与状态更新](#日志记录与状态更新)
7. [关键常量与配置](#关键常量与配置)
8. [防超卖机制](#防超卖机制)
9. [数据断层修复](#数据断层修复)

---

## 概述

### 同步目标

将 **H3YUN（氚云）ERP** 的库存数据同步到 **WooCommerce** 电商网站，实现：
- 有货商品自动上架（outofstock → instock）
- 无货商品自动下架（instock → outofstock）
- 低库存商品同步精确数量（防超卖）

### 核心公式

```
净库存 (netStock) = 可售库存 - 缺货占用
有效库存 (effectiveQuantity) = min(ERP净库存, WC实时库存)  // 防超卖
```

---

## 数据结构

### 内存中的三个关键 Map

```typescript
// 1. 产品状态缓存（来源：Supabase → WC API → 低库存实时拉取）
const productStatus = new Map<string, string>();
// key: SKU, value: 'instock' | 'outofstock'

// 2. Supabase 缓存的库存数量
const supabaseQuantity = new Map<string, number | null>();
// key: SKU, value: 库存数量 (null 表示不管理库存)

// 3. WC 实时库存数量（仅低库存 SKU 会填充）
const wcRealTimeQuantity = new Map<string, number | null>();
// key: SKU, value: WC 实时库存数量
```

### 同步结果统计

```typescript
let syncedToInstock = 0;    // 同步为有货的数量
let syncedToOutofstock = 0; // 同步为无货的数量
let syncedQuantity = 0;     // 同步具体数量的数量（低库存）
let skipped = 0;            // 跳过的数量
let failed = 0;             // 失败的数量

const details: Array<{
  sku: string;
  action: 'to_instock' | 'to_outofstock' | 'sync_quantity' | 'failed';
  quantity?: number;
  error?: string;
}> = [];
```

---

## 产品状态检测（三层缓存策略）

### 第一层：Supabase 缓存查询

```typescript
// 查询 products 表获取缓存的状态和数量
const { data: productCache } = await supabase
  .from('products')
  .select('sku, stock_status, stock_quantity')
  .eq('site_id', siteId);

// 填充 Map
productCache?.forEach(p => {
  if (p.sku) {
    productStatus.set(p.sku, p.stock_status);
    supabaseQuantity.set(p.sku, p.stock_quantity);
  }
});
```

### 第二层：WC API 批量检测（缓存未命中）

```typescript
// 收集缓存未命中的 SKU
const allWooSkus: string[] = [];
for (const item of inventoryData) {
  const sku = item.产品代码;
  const wooSkus = skuMappings[sku] || [sku];
  for (const wooSku of wooSkus) {
    if (!productStatus.has(wooSku) && !allWooSkus.includes(wooSku)) {
      allWooSkus.push(wooSku);
    }
  }
}

// 分批调用 WC API 检测（每批 100 个）
const batchSize = 100;
for (let i = 0; i < allWooSkus.length; i += batchSize) {
  const batch = allWooSkus.slice(i, i + batchSize);

  const detectResult = await detectProducts(
    siteId,
    batch,
    site.url,
    site.api_key,
    site.api_secret,
    false // 不跳过缓存，让 detectProducts 自动写入缓存
  );

  // 将检测结果加入 productStatus Map
  for (const product of detectResult.products) {
    if (product.status !== 'not_found' && product.status !== 'error') {
      productStatus.set(product.sku, product.stockStatus);
    }
  }

  // 批次间延迟 200ms，避免 API 限流
  if (i + batchSize < allWooSkus.length) {
    await new Promise(resolve => setTimeout(resolve, 200));
  }
}

// 检测完成后冷却 1 秒
await new Promise(resolve => setTimeout(resolve, 1000));
```

### 第三层：低库存 SKU 实时拉取（防超卖 + 数据断层修复）

#### 筛选条件（满足任一即加入低库存列表）

```typescript
const LOW_STOCK_THRESHOLD = 10;

// 条件1: ERP库存低 (0 < netStock <= 10)
const erpLowStock = netStock > 0 && netStock <= LOW_STOCK_THRESHOLD;

// 条件2: Supabase缓存库存低 (0 <= sbQuantity <= 10)
// 场景：ERP库存=80，Supabase库存=1，WC实际=outofstock
// 原因：客户下单消耗了WC库存，但变化没同步回Supabase
const supabaseLowStock = sbQuantity !== null && sbQuantity >= 0 && sbQuantity <= LOW_STOCK_THRESHOLD;

// 条件3: Supabase缓存库存为null但状态为instock（数据可能不完整）
const supabaseNullButInstock = sbQuantity === null && currentStatus === 'instock';

// 只处理当前状态为 instock 且无自定义阈值的 SKU
if (currentStatus === 'instock' && instockThreshold === 0) {
  if (erpLowStock || supabaseLowStock || supabaseNullButInstock) {
    lowStockSkus.push(wooSku);
  }
}
```

#### 实时拉取逻辑

```typescript
// 分批处理，每批 20 个（避免 URL 过长）
const batchSize = 20;
for (let i = 0; i < lowStockSkus.length; i += batchSize) {
  const batch = lowStockSkus.slice(i, i + batchSize);

  // 使用 sku 参数批量查询
  const skuParam = batch.join(',');
  const searchUrl = `${cleanUrl}/wp-json/wc/v3/products?sku=${encodeURIComponent(skuParam)}&per_page=100`;

  const response = await fetch(searchUrl, {
    headers: { 'Authorization': `Basic ${auth}` }
  });

  if (response.ok) {
    const products = await response.json();
    for (const product of products) {
      if (product.sku) {
        // 保留 null 值：null="不管理库存"，0="库存耗尽"
        const quantity = product.stock_quantity;
        const status = product.stock_status || 'instock';

        wcRealTimeQuantity.set(product.sku, quantity);
        supabaseUpdates.push({ sku: product.sku, stock_quantity: quantity ?? 0, stock_status: status });
      }

      // 处理变体产品
      if (product.variations && Array.isArray(product.variations)) {
        for (const variation of product.variations) {
          // 同样处理...
        }
      }
    }
  }

  // 批次间延迟 300ms
  if (i + batchSize < lowStockSkus.length) {
    await new Promise(resolve => setTimeout(resolve, 300));
  }
}

// 批量更新 Supabase 缓存
await Promise.all(supabaseUpdates.map(item =>
  supabase
    .from('products')
    .update({
      stock_quantity: item.stock_quantity,
      stock_status: item.stock_status,
      synced_at: new Date().toISOString()
    })
    .eq('site_id', siteId)
    .eq('sku', item.sku)
));

// 关键：更新内存中的 Map，供后续同步判断使用
for (const item of supabaseUpdates) {
  productStatus.set(item.sku, item.stock_status);
  supabaseQuantity.set(item.sku, item.stock_quantity);
}
```

---

## 同步决策逻辑（四种情况）

### 前置计算

```typescript
// 获取 SKU 的自定义有货阈值（默认 0，即 netStock > 0 为有货）
const instockThreshold = getSkuInstockThreshold(sku, syncRules);

// 判断按阈值规则是否算作"有货"
const isInStock = netStock > instockThreshold;
```

### 情况1：WC有货 → ERP无货 → 同步为无货

```typescript
if (currentStatus === 'instock' && !isInStock && config.sync_to_outofstock) {
  // WC显示有货，但ERP库存不足阈值 → 下架
  needSync = true;
  targetStatus = 'outofstock';
}
```

### 情况2：WC有货 + ERP低库存(1-10) → 同步具体数量

```typescript
if (currentStatus === 'instock' && isInStock && netStock <= LOW_STOCK_THRESHOLD && config.sync_to_outofstock) {
  // 仅处理无自定义阈值的 SKU
  if (instockThreshold === 0) {
    const wcQuantity = wcRealTimeQuantity.get(wooSku);
    const wcStatus = productStatus.get(wooSku);

    // 子情况2a: WC已无货，ERP有货 → 补货上架
    if (wcStatus === 'outofstock' || (wcQuantity !== null && wcQuantity <= 0)) {
      needSync = true;
      targetStatus = 'instock';
      syncStockQuantity = netStock; // 以 ERP 库存为准
    }
    // 子情况2b: WC还有货 → 防超卖
    else {
      let effectiveQuantity = netStock;
      if (wcQuantity !== null) {
        effectiveQuantity = Math.min(netStock, wcQuantity); // 取最小值
      }

      // 只有数量不同时才同步
      const currentWcQuantity = wcQuantity ?? supabaseQuantity.get(wooSku);
      if (currentWcQuantity === null || effectiveQuantity !== currentWcQuantity) {
        needSync = true;
        targetStatus = 'instock';
        syncStockQuantity = effectiveQuantity;
      }
    }
  }
}
```

### 情况3：WC无货 + ERP有货 → 同步为有货

```typescript
if (currentStatus === 'outofstock' && isInStock && config.sync_to_instock) {
  // WC显示无货，但ERP有库存 → 上架
  needSync = true;
  targetStatus = 'instock';

  // 低库存时同步具体数量
  if (netStock <= LOW_STOCK_THRESHOLD && instockThreshold === 0) {
    syncStockQuantity = netStock;
  }
}
```

### 情况4：数据断层修复

```typescript
if (currentStatus === 'instock' && isInStock && config.sync_to_instock) {
  // Supabase缓存显示instock，但WC实际outofstock，ERP有货
  // 场景：WC库存被买空后，Supabase缓存没有及时同步
  const wcStatus = productStatus.get(wooSku);
  const wcQuantity = wcRealTimeQuantity.get(wooSku);

  if (wcStatus === 'outofstock' || (wcQuantity !== null && wcQuantity <= 0)) {
    needSync = true;
    targetStatus = 'instock';

    // 高库存只同步状态，低库存同步数量
    if (netStock <= LOW_STOCK_THRESHOLD && instockThreshold === 0) {
      syncStockQuantity = netStock;
    }
  }
}
```

### 决策流程图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           同步决策流程                                   │
└─────────────────────────────────────────────────────────────────────────┘

                    ┌──────────────────┐
                    │ 获取 currentStatus │
                    │ (WC/缓存当前状态)  │
                    └────────┬─────────┘
                             │
              ┌──────────────┴──────────────┐
              ▼                             ▼
      currentStatus = instock        currentStatus = outofstock
              │                             │
              ▼                             ▼
      ┌───────────────┐              ┌───────────────┐
      │ ERP有货(isInStock)?│              │ ERP有货?      │
      └───────┬───────┘              └───────┬───────┘
              │                             │
       ┌──────┴──────┐                      │
       ▼             ▼                      ▼
     是            否                      是
       │             │                      │
       ▼             ▼                      ▼
  ┌─────────┐  ┌─────────────┐       ┌─────────────┐
  │低库存?   │  │情况1:       │       │情况3:       │
  │(1-10)   │  │→ outofstock │       │→ instock   │
  └────┬────┘  └─────────────┘       │(低库存加数量)│
       │                             └─────────────┘
  ┌────┴────┐
  ▼         ▼
 是        否
  │         │
  ▼         ▼
┌───────┐ ┌────────────┐
│情况2:  │ │检查数据断层 │
│防超卖  │ │(情况4)      │
│同步数量│ └────────────┘
└───────┘
```

---

## 执行同步（syncSku函数）

### 函数签名

```typescript
async function syncSku(
  sku: string,                           // WooCommerce SKU
  stockStatus: 'instock' | 'outofstock', // 目标状态
  siteUrl: string,                       // 站点 URL
  consumerKey: string,                   // API Key
  consumerSecret: string,                // API Secret
  siteId: string,                        // 站点 ID
  stockQuantity?: number                 // 可选：同步具体数量（低库存时使用）
): Promise<{ success: boolean; error?: string }>
```

### 执行流程

```typescript
// 1. 搜索产品（支持重试）
const searchUrl = `${cleanUrl}/wp-json/wc/v3/products?sku=${encodeURIComponent(sku)}`;

for (let attempt = 1; attempt <= maxRetries; attempt++) {
  const searchResponse = await fetch(searchUrl, {
    method: 'GET',
    headers: {
      'Authorization': `Basic ${auth}`,
      'Content-Type': 'application/json',
    },
  });

  if (searchResponse.ok) {
    products = await searchResponse.json();
    if (products.length > 0) break;
  }

  // 失败则等待后重试
  await new Promise(resolve => setTimeout(resolve, 1000));
}

// 2. 判断产品类型（简单产品 vs 变体产品）
const product = products[0];
const isVariation = product.type === 'variation';

let updateUrl: string;
if (isVariation) {
  // 变体产品使用变体 API 端点
  const parentId = product.parent_id;
  updateUrl = `${cleanUrl}/wp-json/wc/v3/products/${parentId}/variations/${product.id}`;
} else {
  // 普通产品使用标准端点
  updateUrl = `${cleanUrl}/wp-json/wc/v3/products/${product.id}`;
}

// 3. 构建更新数据
const updateData: Record<string, unknown> = {
  stock_status: stockStatus
};

if (stockQuantity !== undefined) {
  // 低库存：启用库存管理，设置具体数量
  updateData.manage_stock = true;
  updateData.stock_quantity = stockQuantity;
  // 根据数量自动设置状态
  updateData.stock_status = stockQuantity <= 0 ? 'outofstock' : 'instock';
} else if (stockStatus === 'instock') {
  // 有货：关闭库存管理，让 stock_status 完全控制
  updateData.manage_stock = false;
} else if (stockStatus === 'outofstock') {
  // 无货：启用库存管理，设置数量为 0
  updateData.manage_stock = true;
  updateData.stock_quantity = 0;
}

// 4. 发送更新请求
const updateResponse = await fetch(updateUrl, {
  method: 'PUT',
  headers: {
    'Authorization': `Basic ${auth}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(updateData)
});

// 5. 同步成功后更新本地缓存
if (updateResponse.ok) {
  const updatedProduct = await updateResponse.json();

  // 并行更新 products 和 product_variations 表
  await Promise.all([
    supabase
      .from('products')
      .update({
        stock_status: updatedProduct.stock_status,
        stock_quantity: updatedProduct.stock_quantity,
        manage_stock: updatedProduct.manage_stock,
        synced_at: new Date().toISOString(),
      })
      .eq('site_id', siteId)
      .eq('sku', sku),
    supabase
      .from('product_variations')
      .update(/* 同上 */)
      .eq('sku', sku)
  ]);
}
```

### 同步后延迟

```typescript
const SYNC_DELAY = 200; // 每次同步后延迟 200ms

// 执行同步
const result = await syncSku(wooSku, targetStatus, ...);

// 延迟，避免 API 限流
await new Promise(resolve => setTimeout(resolve, SYNC_DELAY));
```

---

## 日志记录与状态更新

### 更新站点最后同步时间

```typescript
const completedAt = new Date().toISOString();

await supabase
  .from('wc_sites')
  .update({ last_sync_at: completedAt })
  .eq('id', siteId);
```

### 记录同步日志（auto_sync_logs 表）

```typescript
// 确定状态
let status: 'success' | 'partial' | 'no_changes' | 'failed' = 'success';
if (failed > 0) {
  status = 'partial';
} else if (syncedToInstock === 0 && syncedToOutofstock === 0 && syncedQuantity === 0) {
  status = 'no_changes';
}

// 插入日志
await supabase
  .from('auto_sync_logs')
  .insert({
    config_id: config.id || 'default',
    started_at: startedAt,
    completed_at: completedAt,
    status,
    total_skus_checked: inventoryData.length,
    skus_synced_to_instock: syncedToInstock,
    skus_synced_to_outofstock: syncedToOutofstock,
    skus_failed: failed,
    sites_processed: { [site.name]: summary },
    error_message: null,
    notification_sent: false,
    notification_error: null,
  });
```

### 更新同步配置（auto_sync_config 表）

```typescript
await supabase
  .from('auto_sync_config')
  .update({
    last_run_at: completedAt,
    last_run_status: status,
    last_run_summary: {
      total_sites: 1,
      total_checked: inventoryData.length,
      total_synced_to_instock: syncedToInstock,
      total_synced_to_outofstock: syncedToOutofstock,
      total_failed: failed,
      total_skipped: skipped,
      duration_ms: new Date(completedAt).getTime() - new Date(startedAt).getTime(),
    },
  })
  .eq('name', 'default');
```

---

## 关键常量与配置

```typescript
// 低库存阈值：当净库存在 1-10 时，同步具体数量而非仅状态
const LOW_STOCK_THRESHOLD = 10;

// API 限流控制
const SYNC_DELAY = 200;           // 每次同步后延迟 200ms
const API_COOLDOWN = 1000;        // API 检测完成后冷却 1 秒
const DETECT_BATCH_SIZE = 100;    // 产品检测批次大小
const LOW_STOCK_BATCH_SIZE = 20;  // 低库存实时拉取批次大小
const LOW_STOCK_DELAY = 300;      // 低库存批次间延迟 300ms

// 同步配置（来自 auto_sync_config）
config.sync_to_instock     // 是否同步为有货
config.sync_to_outofstock  // 是否同步为无货
```

---

## 防超卖机制

### 核心原理

```
有效库存 = min(ERP净库存, WC实时库存)
```

### 为什么需要防超卖？

1. **ERP 数据可能有延迟**：客户在 WC 下单后，ERP 可能还没减库存
2. **多渠道销售**：同一 SKU 可能在多个平台销售
3. **避免超额承诺**：同步的库存数量不应超过任一系统的实际库存

### 实现代码

```typescript
// WC 还有货时，防超卖处理
let effectiveQuantity = netStock; // 默认使用 ERP 库存

if (wcQuantity !== null && wcQuantity !== undefined) {
  effectiveQuantity = Math.min(netStock, wcQuantity); // 取最小值
}

console.log(`防超卖: ERP=${netStock}, WC实时=${wcQuantity} → 有效库存=${effectiveQuantity}`);

// 只有数量不同时才同步
if (effectiveQuantity !== currentWcQuantity) {
  needSync = true;
  syncStockQuantity = effectiveQuantity;
}
```

---

## 数据断层修复

### 什么是数据断层？

```
场景：
1. 初始状态：ERP=80, Supabase=80(instock), WC=80(instock)
2. 客户在 WC 下单购买 80 件
3. WC 状态变为：WC=0(outofstock)
4. 但 Supabase 缓存仍为：Supabase=80(instock) ← 数据断层！
5. ERP 也可能未及时减库存：ERP=80

问题：
- 下次同步时，currentStatus=instock, isInStock=true
- 按正常逻辑会被跳过
- 但 WC 实际已无货，需要补货上架
```

### 修复逻辑

```typescript
// 情况4：数据断层修复
if (currentStatus === 'instock' && isInStock && config.sync_to_instock) {
  // 获取 WC 实时状态（在低库存拉取阶段已更新到内存 Map）
  const wcStatus = productStatus.get(wooSku);
  const wcQuantity = wcRealTimeQuantity.get(wooSku);

  // 检查：缓存说 instock，但 WC 实际 outofstock
  if (wcStatus === 'outofstock' || (wcQuantity !== null && wcQuantity <= 0)) {
    console.log(`数据断层修复: Supabase=${currentStatus}, WC实际=${wcStatus}(qty=${wcQuantity}), ERP=${netStock} → 补货上架`);

    needSync = true;
    targetStatus = 'instock';

    // 高库存只同步状态，低库存同步数量
    if (netStock <= LOW_STOCK_THRESHOLD) {
      syncStockQuantity = netStock;
    }
  }
}
```

### 触发条件

数据断层修复依赖于第三层缓存（低库存实时拉取）：

```typescript
// 条件2: Supabase缓存库存低（修复数据断层）
const supabaseLowStock = sbQuantity !== null && sbQuantity >= 0 && sbQuantity <= LOW_STOCK_THRESHOLD;

// 条件3: Supabase缓存库存为null但状态为instock
const supabaseNullButInstock = sbQuantity === null && currentStatus === 'instock';
```

---

## 完整流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              自动同步完整流程                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────────────┐
│ 1. 参数解析       │
│ slot → siteId   │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 2. 配置检查       │
│ • 自动同步启用?   │
│ • 站点在列表中?   │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 3. 获取站点信息    │
│ • API 凭据       │
│ • 筛选配置       │
│ • 同步规则       │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 4. 拉取 ERP 数据  │
│ H3YUN API       │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 5. 数据筛选合并    │
│ • 仓库规则       │
│ • 品类筛选       │
│ • SKU白名单/排除  │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ 6. 加载 SKU 映射  │
│ H3YUN → WC      │
└────────┬─────────┘
         │
         ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 7. 产品状态检测（三层缓存）                                                 │
│                                                                          │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────────┐   │
│  │ 第一层          │    │ 第二层          │    │ 第三层              │   │
│  │ Supabase 缓存   │───>│ WC API 批量检测  │───>│ 低库存实时拉取      │   │
│  │ (products 表)   │    │ (缓存未命中)     │    │ (防超卖+断层修复)    │   │
│  └─────────────────┘    └─────────────────┘    └─────────────────────┘   │
│                                                                          │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 8. 同步决策（四种情况）                                                     │
│                                                                          │
│  情况1: WC=instock, ERP≤阈值      → outofstock                           │
│  情况2: WC=instock, ERP=1-10      → 同步数量 (防超卖)                     │
│  情况3: WC=outofstock, ERP>阈值   → instock                              │
│  情况4: 缓存=instock, WC实际=outofstock, ERP有货 → 数据断层修复            │
│                                                                          │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 9. 执行同步 (syncSku)                                                     │
│                                                                          │
│  搜索产品 → 判断类型 → PUT 更新 → 更新缓存                                  │
│                                                                          │
│  每次同步后延迟 200ms                                                     │
│                                                                          │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 10. 日志记录 & 状态更新                                                    │
│                                                                          │
│  • wc_sites.last_sync_at                                                 │
│  • auto_sync_logs (同步日志)                                              │
│  • auto_sync_config.last_run_* (配置状态)                                 │
│                                                                          │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 11. 企业微信通知                                                          │
│                                                                          │
│  • 单站点通知（每个站点完成时）                                             │
│  • 本轮总结通知（最后一个站点完成时）                                       │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

---

## 相关文件

| 文件路径 | 说明 |
|---------|------|
| `src/app/api/sync/single-site/route.ts` | 单站点定时同步 API（本文档主要分析对象） |
| `src/lib/product-detection.ts` | 产品检测函数 |
| `src/lib/sync-rules.ts` | 同步规则引擎 |
| `src/store/multisite.ts` | 多站点状态管理 |

---

## 数据库表

| 表名 | 说明 |
|------|------|
| `wc_sites` | WooCommerce 站点配置 |
| `site_filters` | 站点筛选配置（含同步规则） |
| `products` | 产品缓存（状态、数量） |
| `product_variations` | 变体产品缓存 |
| `auto_sync_config` | 自动同步配置 |
| `auto_sync_logs` | 自动同步日志 |

---

*文档生成时间: 2026-01-23*
*源文件: `/src/app/api/sync/single-site/route.ts`*